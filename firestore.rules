rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============= HELPER FUNCTIONS =============

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isNonEmptyString(field) {
      return field is string && field.size() > 0;
    }

    function isStringOrNull(field) {
      return field is string || field == null;
    }

    // Allowed fields for user profile documents
    function validUserFields() {
      return ['email', 'displayName', 'photoURL', 'emailNotifications', 'reminderDays', 'createdAt', 'updatedAt'];
    }

    // Required fields for subscription documents
    function requiredSubscriptionFields() {
      return ['name', 'icon', 'dueDate', 'price', 'billing', 'category', 'createdAt'];
    }

    // All allowed fields for subscription documents
    function allowedSubscriptionFields() {
      return ['name', 'icon', 'dueDate', 'price', 'billing', 'category', 'createdAt', 'updatedAt'];
    }

    // Required fields for notification documents
    function requiredNotificationFields() {
      return ['subscriptionId', 'subscriptionName', 'dueDate', 'billing',
              'renewalDate', 'sendAt', 'notifyDaysBefore', 'read', 'dismissed', 'createdAt'];
    }

    // All allowed fields for notification documents
    function allowedNotificationFields() {
      return ['subscriptionId', 'subscriptionName', 'dueDate', 'billing',
              'renewalDate', 'sendAt', 'notifyDaysBefore', 'read', 'dismissed',
              'createdAt', 'readAt', 'dismissedAt'];
    }

    // ============= USERS COLLECTION =============

    match /users/{userId} {

      allow read: if isOwner(userId);

      // Profile creation: enforce required fields, types, and server timestamps
      allow create: if isOwner(userId)
                    && request.resource.data.keys().hasAll(validUserFields())
                    && request.resource.data.keys().hasOnly(validUserFields())
                    && isStringOrNull(request.resource.data.email)
                    && isStringOrNull(request.resource.data.displayName)
                    && isStringOrNull(request.resource.data.photoURL)
                    && request.resource.data.emailNotifications is bool
                    && request.resource.data.reminderDays is number
                    && request.resource.data.reminderDays >= 1
                    && request.resource.data.reminderDays <= 30
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.updatedAt == request.time;

      // Profile update: no extra fields, createdAt immutable, updatedAt must refresh
      allow update: if isOwner(userId)
                    && request.resource.data.keys().hasOnly(validUserFields())
                    && isStringOrNull(request.resource.data.email)
                    && isStringOrNull(request.resource.data.displayName)
                    && isStringOrNull(request.resource.data.photoURL)
                    && request.resource.data.emailNotifications is bool
                    && request.resource.data.reminderDays is number
                    && request.resource.data.reminderDays >= 1
                    && request.resource.data.reminderDays <= 30
                    && request.resource.data.createdAt == resource.data.createdAt
                    && request.resource.data.updatedAt == request.time;

      // ============= SUBSCRIPTIONS SUBCOLLECTION =============

      match /subscriptions/{subscriptionId} {

        allow read: if isOwner(userId);

        // Validate all fields on creation
        allow create: if isOwner(userId)
                      && request.resource.data.keys().hasAll(requiredSubscriptionFields())
                      && request.resource.data.keys().hasOnly(allowedSubscriptionFields())
                      && isNonEmptyString(request.resource.data.name)
                      && request.resource.data.name.size() <= 100
                      && request.resource.data.icon is string
                      && isNonEmptyString(request.resource.data.dueDate)
                      && request.resource.data.price is number
                      && request.resource.data.price >= 0
                      && request.resource.data.price <= 99999
                      && request.resource.data.billing in ['Monthly', 'Yearly']
                      && isNonEmptyString(request.resource.data.category)
                      && request.resource.data.category.size() <= 50
                      && request.resource.data.createdAt is string;

        // Validate fields on update, createdAt is immutable
        allow update: if isOwner(userId)
                      && request.resource.data.keys().hasAll(requiredSubscriptionFields())
                      && request.resource.data.keys().hasOnly(allowedSubscriptionFields())
                      && isNonEmptyString(request.resource.data.name)
                      && request.resource.data.name.size() <= 100
                      && request.resource.data.icon is string
                      && isNonEmptyString(request.resource.data.dueDate)
                      && request.resource.data.price is number
                      && request.resource.data.price >= 0
                      && request.resource.data.price <= 99999
                      && request.resource.data.billing in ['Monthly', 'Yearly']
                      && isNonEmptyString(request.resource.data.category)
                      && request.resource.data.category.size() <= 50
                      && request.resource.data.createdAt == resource.data.createdAt;

        allow delete: if isOwner(userId);
      }

      // ============= NOTIFICATIONS SUBCOLLECTION =============

      match /notifications/{notificationId} {

        allow read: if isOwner(userId);

        // Validate all fields on creation, new notifications must be unread/undismissed
        allow create: if isOwner(userId)
                      && request.resource.data.keys().hasAll(requiredNotificationFields())
                      && request.resource.data.keys().hasOnly(allowedNotificationFields())
                      && isNonEmptyString(request.resource.data.subscriptionId)
                      && isNonEmptyString(request.resource.data.subscriptionName)
                      && isNonEmptyString(request.resource.data.dueDate)
                      && request.resource.data.billing in ['Monthly', 'Yearly']
                      && request.resource.data.renewalDate is string
                      && request.resource.data.sendAt is string
                      && request.resource.data.notifyDaysBefore is number
                      && request.resource.data.notifyDaysBefore >= 0
                      && request.resource.data.notifyDaysBefore <= 30
                      && request.resource.data.read == false
                      && request.resource.data.dismissed == false
                      && request.resource.data.createdAt is string;

        // Only allow updating read/dismissed status â€” no other fields can change
        allow update: if isOwner(userId)
                      && request.resource.data.diff(resource.data).affectedKeys()
                          .hasOnly(['read', 'readAt', 'dismissed', 'dismissedAt'])
                      && request.resource.data.read is bool
                      && request.resource.data.dismissed is bool;

        allow delete: if isOwner(userId);
      }
    }

    // ============= DENY ALL OTHER ACCESS =============
    // Any collection not matched above is denied by default
  }
}